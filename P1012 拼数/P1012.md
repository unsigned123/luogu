第一反应是使用高精度+朴素DP。
教训：1.注意高精度的数字拼接的坑orz
2.注意resize时vector补0等等

然而，实际上并不需要使用高精度。
本题的标签是“字符串”“贪心”“排序”“状压DP”
最简单的做法是直接把这些数字使用字典序排列之后拼接起来就行！！！
唉唉。。其实猜到这个想法了。。

什么是状压DP？
状态压缩DP（State Compression DP）是一种特殊的动态规划，通常用于解决集合问题。当问题涉及到从n个元素中选择一个子集，且n不大（通常n≤20）时，我们可以用二进制数来表示集合状态：

每个元素用1个bit表示：1表示选中，0表示未选中

一个n位的二进制数可以表示2ⁿ种状态

例如：n=3，二进制数101表示选中了第0个和第2个元素

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<string> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    // dp[mask] 表示选择了mask对应元素时的最大拼接结果
    vector<string> dp(1 << n);
    
    // 枚举所有状态
    for (int mask = 0; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            if (!(mask & (1 << i))) { // 如果第i个元素不在当前状态中
                int new_mask = mask | (1 << i);
                string candidate = dp[mask] + nums[i];
                
                // 更新新状态
                if (candidate > dp[new_mask]) {
                    dp[new_mask] = candidate;
                }
            }
        }
    }
    
    // 最终状态：所有元素都被选中
    cout << dp[(1 << n) - 1] << endl;
    
    return 0;
}

学习状态压缩DP的做法！！