和P1004非常相似的棋盘DP
此类棋盘DP用三维DP最好，这样非常方便处理“不能在同一位置”的问题

只需要注意f[s][i][j]的i和j都是行序号数而不是一个行一个列就行

附：四维DP解法
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[60][60];
int dp[60][60][60][60];
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int m, n;
	cin >> m >> n;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= m; k++) {
				for (int l = 1; l <= n; l++) {
					dp[i][j][k][l] = max(dp[i - 1][j][k - 1][l], dp[i - 1][j][k][l - 1]);
					dp[i][j][k][l] = max(dp[i][j - 1][k - 1][l], max(dp[i][j][k][l], dp[i][j - 1][k][l - 1]));
					dp[i][j][k][l] += a[i][j] + a[k][l];
					if (i == k && j == l && !(i == 1 && j == 1 || i == m && j == n)) {
						dp[i][j][k][l] = -114514;
					}
				}
			}
		}
	}
	cout << dp[m][n][m][n];
	return 0;
}

TODO:另外，这道题也有一种“费用流”的做法。