1.必须注意这里不能使用贪心，会得不到全局最优解
2.注意学习DP的边界处理的各种各样的坑，注意好每个变量的边界
3.这是很好的DP典例，DP分类为(多维)的线性DP

TODO:学习滚动数组，考虑使用滚动数组重做


附：DP模板
// 1. 初始化：设置起点
dp[0][0][0] = 初始值;

// 2. 主循环
for (int 阶段 = 1; 阶段 <= 总阶段数; 阶段++) {
    for (int 状态1 = 合法下界; 状态1 <= 合法上界; 状态1++) {
        for (int 状态2 = 合法下界; 状态2 <= 合法上界; 状态2++) {
            // 3. 初始化当前状态（可选）
            dp[阶段][状态1][状态2] = 0或负无穷;
            
            // 4. 遍历所有可能的转移
            for (每种转移方式) {
                if (前驱状态合法) {
                    //这里要注意边界情况，边界情况可能影响max min里面的对象
                    dp[阶段][状态1][状态2] = max/min(...);
                }
            }
            
            // 5. 加上当前贡献
            dp[阶段][状态1][状态2] += 当前值;
        }
    }
}